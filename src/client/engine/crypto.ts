import nacl from 'tweetnacl'
import { b64, utf8 } from './crypto/primitives/codec'

/**
 * Cipher objects are generated by encryption methods,
 * such as nacl.box or nacl.secretbox.
 * The nonce is available in clear text and travels
 * with the ciphertext for later decryption.
 */
export interface Cipher {
  text: Uint8Array
  nonce: Uint8Array
}

export const serializeCipher = (cipher: Cipher): string => {
  return ['v1', b64.encode(cipher.text), b64.encode(cipher.nonce)].join('.')
}
export const deserializeCipher = (cipher: string): Cipher | null => {
  if (cipher.startsWith('v1.')) {
    const [_, text, nonce] = cipher.split('.')
    return {
      text: b64.decode(text),
      nonce: b64.decode(nonce)
    }
  }
  return null
}

export interface DataPoint {
  message: string
  nonce: string
  publicKey: string
}

export const decryptDataPoint = (
  dataPoint: DataPoint,
  secretKey: Uint8Array
) => {
  const message = b64.decode(dataPoint.message)
  const nonce = b64.decode(dataPoint.nonce)
  const publicKey = b64.decode(dataPoint.publicKey)
  const deciphered = nacl.box.open(message, nonce, publicKey, secretKey)
  if (!deciphered) {
    return null
  }
  return JSON.parse(utf8.decode(deciphered))
}

export const encryptDataPoint = <T>(
  data: T,
  publicKey: Uint8Array
): DataPoint => {
  const keyPair = nacl.box.keyPair()
  const clearText = utf8.encode(JSON.stringify(data))
  const nonce = nacl.randomBytes(nacl.box.nonceLength)
  const cipher = nacl.box(clearText, nonce, publicKey, keyPair.secretKey)
  return {
    message: b64.encode(cipher),
    nonce: b64.encode(nonce),
    publicKey: b64.encode(keyPair.publicKey)
  }
}
